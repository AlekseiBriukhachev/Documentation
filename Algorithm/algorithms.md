# Асимптотический анализ алгоритмов

Во время анализа рассматриваются две величины: время, которое затратит наш алгоритм, и память, которую будет использовать. Время также называется сложностью алгоритма.

Случаи, который рассматриваются во время этих анализов:

1. *Худший случай*
На практике обычно используется только худший случай. Подразумевает на сколько долго будет работать алгоритм. Сложность обозначается в виде большого **О(n)**, где (n) - это функция, котора растет пропорционально нашим действиям.  

- Алгоритм поиска элемента
```java
private int search(int[] a, int x) { //O(n)
        for (int i = 0; i < a.length; i++) {
            if (a[i] == x) {
                return i;
            }
        }
        return -1;
    }
```
В данном случае скорость выполнения алгоритма зависит от длинны массива O(n).

- Алгоритм перемены местами двух чисел
```java
private void swap(int& a, int& b) { 
        int t = a;
        a = b;
        b = t;
    }
```
В данном случае скорость выполнения алгоритма зависит от длинны массива O(1) поскольку всегда выполняется только три действия. Это называется константное время

- Алгоритм с двумя циклами
```java
private void cycle_n(int n, int m) { 
        for(int i = 0; i < n; i++) {
            System.out.println(i)
        }
        for(int i = 0; i < m; i++) {
            System.out.println(i)
        }
        
    }
```
В данном случае скорость выполнения алгоритма зависит от длинны массива O(n + m) поскольку здесь два целла, независящих друг от друга и работающих в зависимости от переменных, неизвестной величины.

2. *Лучший случай*
3. *Средний случай*

## 2. Стэк (Stack)

Стэк - это структура данных, которая позволяет добавлять элемент с одного конца, и удалять элемент с того же самого конца. Структура данных типа **LIFO** - Last Input First Output. Имеет три метода push(), pop(), top(). Все они работают за одинаковое время **О(1)**, т.е. для каждой из этих операций делается константное количество действий не зависящее от количества элементов.

```java
int main() {
    Stack<Integer> st;
    st.push(2);
    st.push(7);
    st.top(); // 7
    st.pop();
    st.push(3);
    st.push(4);
    st.top(); // 4
    st.pop();
    st.top(); // 3
    st.pop();
}
```

Другая задача со строкой: нужно определить, является ли строка сбалансированной скобочной последовательностью. Сбалансированной скобочная последовательность называется в том случае, когда для каждой открывающейся скобки есть ее закрывающая и в правильной последовательности, т.е. открывающаяся - закрывающаяся, а также если внутри скобок также находится сбалансированная скобочная последовательность. 
```java
int main() {
    Stirng s1 = "()({[]})())"; // true
    Stirng s2 = "{}"; // true
    Stirng s3 = "}{"; // false
    Stirng s4 = ""; // true
    Stirng s5 = "(()"; // false
    Stirng s6 = "())"; // false
    Stirng s7 = "[(])"; // false
}

Boolean isBalanced(Stirng s) {
    //"()({[]})())"
        
        Stack<Character> st;
        for (int i = 0; i < s.size(); i++) {
            if (isOpen(s[i])) {
                st.push(st[i]);
            } else {
                if (!st.empty() && isPair(st.top(), s[i])) {
                    st.pop();    
                } else {
                    return false;    
                }
            }
        }
        return st.empty();
}

Boolean isOpen(Character ch) {
    return ch == '(' || '{' || '[';
}

Boolean isPair(Character open, Character close) {
    return open == '{' && close == '}' ||
        open == '[' && close == ']' ||
        open == '(' && close == ')';
}
```

## 3. Очередь (Queue)

Очередь - это такая же структура данных как и стек, только данные входят с одного конца, а выходят с другого. **FIFO** - First Input First Output. Имеет три метода push(), pop(), top().

## 4. Сортировка выбором

Задача: отсортировать массив от меньшего к большему.

Решение: 
1. находится наибольший элемент и меняется с последним элементом.
2. далее рассматривается массив с количеством элементов (n - 1)
3. также находится наибольший элемент и ставится на последнее место в массиве размерности (n - 1)
4. далее рассматривается массив с количеством элементов (n - 2)
5. также находится наибольший элемент и ставится на последнее место в массиве размерности (n - 2)
Сложность данного алгоритма: (n*(n+1))/2 ~ О(n^2)

```java
for (int i = 0; i < array.length(); i++){
    int min=i;
    for(int j = i + 1; j < array.length(); j++){
        if(array[min] > array[j]){
            min = j;
        }
    }
    swap(array[i],array[min]);
}
```

## 5. Пузырьковая сортировка

Пузырьковая сортировка состоит из этапов (n -1). В течении каждого из этапов делаем:
1. берем первый и второй элемент, и если первый больше второго, то меняем их местами.
2. потом берем второй и третий элемент, и опять их сравниваем, и меняем их местами.
3. и так далее мы делаем для всех элементов до конца массива.
4. в итоге мы самый большой элемент проталкиваем в самый конец массива (пузырек)
Сложность этой сортировки: (n - 1) + (n - 2) + (n - 3) + ... + 1 ~ О(n^2)

```java
for (int j = 1; j < array.length(); j++){
    for (int i = 1; i < array.length() - j; i++){
        if(array[i] < array[i - 1]) {
            swap(array[i], array[min]);
        }
    }
}
```

## 6. Сортировка вставкой

1. Начиная со второго элемента мы будем его толкать до тех пор, пока он не окажется вначале или элемент, который пере ним не окажется меньше чем наш элемент.
2. и так для каждого последующего элемента
Сложность этой сортировки в худшем случае: 1 + 2 + 3 + ... + (n - 1) ~ О(n^2)
Очень хорошо работает на маленьких массивах и на массивах, которые уже почти отсортированы.

```java
for (int i = 1; i < array.length(); i++){
    int cur = array[i];
    int j = i - 1;
    while (j >= 0 && array[j] > cur) {
        array[j + 1] = array[j];
        --j;
    }
    array[j + 1] = cur;
}
```

## 6. [Сортировка подсчетом](https://robotdreams.cc/blog/442-povniy-gayd-z-algoritmiv-sortuvannya-na-java)

Отличается от остальных сортировок, что мы здесь не сравниваем элементы друг с другом. 
1. создается временный массив размерностью равным самому большому элементу.
2. потом в каждую ячейку массива записывается количество элементом в сортируемом массиве, соответсвующих номеру элементов временного массива, т.е. сколько 1, сколько 2, сколько 3 и т.д. до последнего элемента. 
3. чтобы отсортировать массив нужно:
    - т.к. мы знаем, что у наса например, всего одна 1, то сразу ее запишем
    - потом мы знаем, что у нас две 2, записываются все элементы по счету 2 2
    - есть одна 3
    - есть три 4
    - одна 5
    - две 6
    - две 9
    - одна 12
    - финальный отсортированный массив: **1 2 2 3 4 4 4 5 6 6 9 9 12**

Сложность этой сортировки в худшем случае: n + m ~ О(n + m)

```java
   int size = array.length;
   int[] output = new int[size + 1];
   // Find the maximum value in the array
   int max = array[0];
   for (int i = 1; i < size; i++) {
      if (array[i] > max)
        max = array[i];
   }
   // Create count array and fill it with zeros
   int[] count = new int[max + 1];
   for (int i = 0; i < max; ++i) {
        count[i] = 0;
   }
   // Find and store the count of each element
   for (int i = 0; i < size; i++) {
        count[array[i]]++;
   }
   // Calculate and store cummulative sum of elements of count array
   for (int i = 1; i <= max; i++) {
        count[i] += count[i - 1];
   }
   // Traverse the initial array from the end and place the elements
   // in output array into their respective positions
   for (int i = size - 1; i >= 0; i--) {
         output[count[array[i]] - 1] = array[i];
         count[array[i]]--;
   }
   // Copy the sorted elements into the initial array
   for (int i = 0; i < size; i++) {
        array[i] = output[i];
   }
```

## [7. Сортировка слиянием](https://javarush.com/groups/posts/2202-sortirovka-slijaniem-merge-sort)

Скорость этой сортировки: О(n*log n).

Плюсы данной сортировки:
1. Быстрая, скорость гарантирована всегда работает за О(n*log n)
2. Можно сортировать большие массивы и большие данные

Минусы:
1. Для нее нужна дополнительная память
2. Нельзя без использования памяти использовать эту сортировку

## 8. [Быстрая сортировка](https://robotdreams.cc/blog/442-povniy-gayd-z-algoritmiv-sortuvannya-na-java)
1. Берется первый элемент, а все остальные элементы с ним сравниваются, при этом меньшие элементы перекидываются в право от данного элемента, а больше элементы остаются в левой части.
2. Полученные данные под массивы - правый и левый - также рекурсивно сортируются по этому же принципу.

## 9. Бинарное возведение в степень

Допустим, у нас есть число a, и нам его нужно возвести в степень n. Данный алгоритм будет работать за время О(n). Это достаточно долго и мы хотим сократить время до О(log n).

## 10. Бинарный поиск

Нужно найти число в массиве. Для этого:
1. Массив делится пополам и берется серединный элемент: `m = (l + r) / 2`. Если искомое число больше данного элемента, то отбрасывается левая часть. Если искомое число меньше данного элемента, то отбрасывается правая часть. 
2. далее в оставшейся части опять находится серединный элемент и сравнивается с искомым числом по тому же самому алгоритму.
3. Сложность алгоритма О(log n).

## 11. Алгоритм Евклида

Алгоритм Евклида используется для того, чтобы найти наибольший общий делитель двух чисел.
Заключается в следующем:
1. (b, a mod(b)), где b - это второе число, а  a mod(b) - это остаток от деления второго числа на первое, например `gcd(15, (21 % 15))`.
`gcd(21, 15) = gcd(15, (21 % 15)) = gcd(15, 6) = ... = gcd(3, 0) = 3`

Время работа алгоритма оценивается теоремой Ламе, которая показывает зависимость между алгоритмом Евклида и последовательностью Фибоначчи. О(log min(a, b))

## 12. Решето Эратосфена

Решето Эратосфена - это алгоритм, позволяющий найти все простые числа в отрезке [1, n]. Используется О(n) памяти и сложность алгоритма О(n * log(log n))
Во время работы данного алгоритма, он прыгает с элемента на элемент, при обработке дальних элементов, алгоритм выскакивает за пределы кэша, поэтому необходимо подгружать память, из-за чего скорость может немного падать.
Оптимизации:
1. самая очевидная - для того чтобы найти все простые числа до n достаточно выполнить просеивание только теми простыми числами, которые не превосходят корня нашего n.
2. известно, что простым четным числом является только одна 2, мы можем вдвое сократить объем потребляемой памяти.

```java
boolean[] mark = new boolean[n];
        Arrays.fill(mark, true);
        for (int i = 3; i * i < n; i += 2) {
            if (mark[i]) {
                for (int j = i * i; j < n; j += i) {
                    mark[j] = false;
                }
            }
        }
```

## 13. Функция Эйлера

Это функция от одной переменной и она равна количеству позитивных чисел, с которыми взаимно проста n (аргумент функции) [1; n]. Два числа a, b называются взаимно простые, если их наибольший общий делитель равняется 1 `gcd(a, b) = 1`. Алгоритм работает за время О(n*log n).

```java
public int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;    
}
public int eulerf(int n) {
		int count = 0;
		for (int i = 1; i <= n; ++i) {
    	    if (gcd(i, n) == 1) {
    	        count++;
    	    } 
    	} 
    	return count; 
}
```

## 14. Hash функция

Hash функция - это функция, которая принимает в себя объект любого типа и возвращает при этом какое-то число. Hash функция необратима, т.е. по Hash мы не получим обратно объект. Потому что один и тот же элемент могут иметь одинаковый hash. Данная ситуация назывется коллизей. 

## 15. Hash таблица

Hash таблица - это структура данных, которая является ассоциативным массивом, а именно она позволяет хранить пары **ключ-значение**. Выполняет на не 3 операции: добавление новой пары, поиск пары по ключу и удаление пары по ключу.  

Hash таблица для хранения элементов использует массив, который называется **bucket** или **slot**. Этот массив обычно бывает величины `m`. И когда мы пытаемся добавить элемент в таблицу, должен высчитаться тндекс, под которым будем содержаться данный элемент. Индекс высчитывается с помощью hash функции. После высчитывания hash функции, мы берем остаток от деления на `m` (длинны массива) и под этой конкретной ячейкой мы записываем наше значение пары ключ-значение. При этом hash высчитывается именно на ключе, значение остаётся не тронутым, и оно просто сохранится вместе с ключом. Значения может вообще не быть, ключ может совпадать со значением, тогда это будет **hashSet**, и мы будем в нем хранить не пары ключ-значение, а просто ключи. Hash таблица - это самая популярна, быстрая и удобная структура данных, которая позволяет хранить и искать элементы.

Ячейки массива hash-таблицы могут быть трех типов: List, Array, Tree, т.е. храниться или массив листов, или массив массивов. Храним мы такую структуру для того, чтобы в дальнейшем иметь возможность получать элементы, у которых одинаковые hash, т.е. в одной (например первой) может быть несколько элементов, у которых один и тот же hash. При этом нам надо хранить все эти элементы, и в дальнейшем когда мы захотим их поискать какой-то конкретный элемент, нам нужно будет знать под каким индексом находится этот элемент и найти его в этом списке или же сказать, что такого элемента нет. Именно для этого в ячейке hash-таблицы хранится или лист или массив. 

Как происходит добавление элемента:
1. В hash-таблице есть функция h(x). Она по какой-то формуле считает `hash` элементов, которые поступают на ввод в нашу таблицу. Когда мы хотим добавить какой-то элемент, нужно высчитать hash этого элемента, взять по модулю длинны массива - этим мы получим индекс ячейки,  и помещаем элемент в ячейку с этим индексом.
Поиск и удаление элемента:
2. Рассчитывается hash заданного элемента - индекс ячейки
3. Один и тот же элемент всегда имеет тот же самый hash.
4. Проходимся по всем элементам массива, который находится в ячейке с индексом п.1 и находим уже тот элемент, который мы ищем.
5. Просто сравниваем каждый элемент с тем, который мы ищем.
Удаление происходит точно также:
6. мы находим элемент
7. и удаляем

Сложность: добавление, поиск или удаление О(1)

## 15. Фильтр Блюма

Блюм фильтр - это структура данных, которая позволяет делать две операции: add, test (проверка есть ли элемент в этой структуре данных). Именно операция test, потому что не со 100% вероятностью. Скорость выполнения О(1). Являются дешевым решетом или фильтром перед тем, как делать какие-то тяжелые операции.

Внутри фильтр хранится `m` битов вместо ячеек. Для Блюм фильтра нужно `k` независимых хэш функций, каждая из которых возвращает элемент в диапазоне (0, m - 1). Также в зависимости от значения, которое вернула хэш функция, в ячейку с этим индексом записывается 1.

[Algorithms](https://github.com/levonoganesyan/Algorithms)