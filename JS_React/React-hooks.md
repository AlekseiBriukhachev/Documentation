# 7. Библиотека React. Хуки и средний продвинутый уровень

[7.1 Введение](#71-введение)<br/>
[7.2 useState](#72-usestate)<br/>
[7.3 useEffect](#73-useeffect)<br/>

## 7.1 Введение

Хуки - это функции, которые позволяют делать тоже самое, что в классах, только внутри функциональных компонентов (функции внутри функций). Хуки появились в версии 16.8.

Для чего были созданы хуки? Когда разрабатывается сложное приложение на классах, то оно довольно часто сильно усложняется кучей оберток и сложных конструкций. При помощи хуков код становиться немного проще в плане организации.

Для того, чтобы понимать как работают хуки, необходимо понимать как работает React: что такое состояние, что такое методы жизненного цикла.

[Хуки: ответы на вопросы](https://ru.legacy.reactjs.org/docs/hooks-faq.html)

[Правила работы с хуками:](https://ru.legacy.reactjs.org/docs/hooks-rules.html)
1. Хуки следует вызывать только на верхнем уровне, не вызывать хуки внутри циклов, условий или вложенных функций
2. Хуки следует вызывать только внутри функциональных компонентов React, их не надо вызывать из обычных JavaScript функций, которые мы когда-то где-то можем использовать - это даст ошибку.

## 7.2 useState

Управляет состоянием. 

Для создания хука нужно внутри функции создать переменную, которая является массивом элементов `const sliderStateArray = useState();`, здесь `useState()` возвращает массив двух элементов: 
1. элемент - это наш `state`
2. функция, которая будет менять это состояние

Для упрощения работы делают деструктуризацию массива `const [slide, setSlide] = useState();`
здесь **slide** - это `state`, а **setSlide** - это функция.

В состоянии может храниться любой тип данных. Для создания нескольких state, создаются следующая переменная, но с другими названиями state и функции: `const [autoplay, setAutoplay] = useState(false);`

Для изменения состояния внутри основной функции создаем функцию по изменению состояния, используя функцию `setSlide` и `setAutoplay`

```javascript
 function changeSlide(i) {
    setSlide(slide => slide + i);
}

function toggleAutoPlay() {
    setAutoplay(autoplay => !autoplay);
}
```
В функцию внутри всегда следует передавать callback функцию.
Теперь мы можем эти функции применить внутри верстки:

```javascript
return (
    <Container>
        <div className="slider w-50 m-auto">
            <img className="d-block w-100" src="" alt="slider"/>
            <div className="text-center mt-5">
                Active slide {slide} <br/>
                {autoplay ? 'auto' : null}
            </div>
            <div className="buttons mt-3">
                <button
                    className="btn btn-primary me-2"
                    onClick={() => changeSlide(-1)}>-1</button>
                <button
                    className="btn btn-primary me-2"
                    onClick={() => changeSlide(1)}>+1</button>
                <button
                    className="btn btn-primary me-2"
                    onClick={toggleAutoPlay}>Toggle autoplay</button>
            </div>
        </div>

    </Container>
);
```

Можно также все состояния записывать до одной переменной, но тогда в этом случае нужно быть очень внимательным: в функциях нужно будет разворачивать объекты и записывать только измененные значения, иначе у нас потеряются некоторые свойства, которые мы не укажем

```javascript
//записываем все состояния в виде деструктурированного объекта
const [state, setState] = useState({slide: 0, autoplay: false}) 

function changeSlide(i) {
    //в setState разворачиваем объект и добавляем ему измененное состояние
    setState(state => ({...state, slide: state.slide + i}));
}

function toggleAutoPlay() {
    // тоже самое делаем для autoplay
    setState(state => ({...state, autoplay => !state.autoplay}));
}
```

Этот код гораздо сложнее, потому что нужно продумывать состояние объекта, иммутабельность и тд, поэтому рекомендуется разбивать все отдельно.

Оптимизационный вопрос по вычислению начального state-а.


## 7.3 useEffect

Хук работы с эффектами. Эффектами называются операции по загрузке данных, использование каких-то сторонних модулей, запуск таймаутов, логирование или изменение ДОМ-структуры.

**Главное:** не надо путать - есть хуки жизненного цикла, а есть просто хуки. В конструкторе класса и в методе рендер не должно быть эффектов. Поэтому в классах есть методы жизненного цикла. Поэтому мы должны некоторые действия совершать в них.

```javascript
componentDidMount() {
        document.title = `Slide: ${this.state.slide}`;
}

componentDidUpdate(prevProps, prevState, snapshot) {
        document.title = `Slide: ${this.state.slide}`;
}
```

Теперь у нас здесь возникла проблема с повторением кода. Это решается с помощью хука **useEffect**. Функция useEffect() принимает в себя callback-функцию, которая будет вызываться и массив зависимостей: если ни одна из этих зависимостей не изменилась, то эффект будет пропущен. Если массив оставить пустым, то эта функция будет работать как функция **componentDidMount** и вызываться только один раз.

```javascript
useEffect(() => {
    document.title = `Slide: ${slide}`;
}, [slide]);
```
Callback-функция она запоминается и прикрепляется к этому конкретному компоненту. Она будет вызвана после того, как этот компонент отренедрился, т.е. построилось ДОМ-дерево. И дальше эта функция будет вызываться каждый раз, когда компонент обновляется, т.е. обновление state, обновление пропсов, форс-update.

Принцип хуков построен на JavaScript замыканиях, потому что эти переменные остаются в области видимости, это обычные функции. Поэтому **useEffect** может отслеживать ссылки на текущее состояние. Функция, которая заключена во внутрь **useEffect**, меняется при каждом рендере, те создается каждый раз новая функция. 

Можно создавать несколько эффектов с разными параметрами, и даже рекомендуется создавать на каждое действие, которое происходит.

Мы должны помнить про те эффекты, которые идут как подписка. Функции, например таймаут или обработчик событий, при удалении компонента не удаляются. Подобные операции называются подпиской на что-то. Все подписки необходимо удалять при удалении компонента. В классовых компонентах это реализуется при помощи **componentWillUnmount**. В **useEffect** тоже есть такое поведение и реализуется возвращением callback-функции из него.

```javascript
useEffect(() => {
    console.log("Effect")
    document.title = `Slide: ${slide}`;

    window.addEventListener('click', logging);

    return () => {
        window.removeEventListener('click', logging);
    }

}, [slide]);
```
**useEffect** объединил в себе 3 хуа жизненного цикла: **componentDidMount**, **componentDidUpdate**, **componentWillUnmount**.

## 7.4 useCallback

**useCallback** позволяет сохранять мемоизированную функцию, которая может быть пересоздана и пере использована только тогда, когда нам это нужно.

## 7.5 useMemo

**useMemo** позволяет сохранять мемоизированное значение, именно значение, а не функцию, как в **useCallback**. Для запоминания какого-то значения используется хук **useMemo**, для того чтобы мы каждый раз не высчитывали это значение при перерендеринге компонента.

```javascript
const total = useMemo(() => {
    return countTotal(slide);
}, [slide]);
```

Как это работает: когда запускается создание компонента, код доходит до создания **total**, и дальше видит использование хука **useMemo**. Внутри есть callback-функция, которая возвращает это значение, которое вычисляется при помощи другой функции. соответственно в **total** мы уже получаем мемоизированное, т.е. запомненное какое-то значение, которое компонент помнит. И дальше оно уже используется как обычная переменная. И теперь когда у нас меняется state или приходит новый пропс компонент начинает перерендериваться. Но поскольку переменная **total** у нас мемоизирована, и этот state у нас не входит в массив зависимостей, то это значение остается точно таким же.

## 7.6 useRef

Хук **useRef** довольно мощный. Используется для создания рефов: `const myRef = useRef(null);` Работает также, как и в классовых компонентах. Рефы существуют и сохраняются при любом перерендеринге компонента, при этом изменение рефа не вызывает ререндер.

## 7.7 Создание своих собственных хуков

Часто бывает так, что одинаковую логику состояния нам необходимо повторно использовать в нескольких компонентах. Поэтому хорошей практикой является создание абстрактной функции (собственный хук или custom hook), которую потом можно переиспользовать. Его выделяют в отдельный компонент, и можно его переиспользовать в целом приложении. Например:

```javascript
function useInputWithValidate(initialValue) {
    const [value, setValue] = useState(initialValue);

    const onChange = event => {
        setValue(event.target.value);
    }

    const validateInput = () => {
        return value.search(/\d/) >= 0;
    }

    return {value, onChange, validateInput}
}
```
[Сервис готовых хуков](https://usehooks.com/)

## 7.8 Batching

Batching - это когда React объединяет несколько состояний в одну операцию для улучшения производительности. Например, команда `setState` или комбинация функций из хуков всегда старается скомбинировать все изменения state перед тем, как их выполнить. Это позволяет делать меньше перерендеринга компонента и экономить ресурсы компьютера.

## 7.9 [Изменения в версии 18](https://github.com/facebook/react/blob/main/CHANGELOG.md)

useId - Позволяет создавать уникальные идентификаторы.

## 7.10 Навигация в приложении, React Router v5+
[documentation](https://reactrouter.com/en/main)
[Версии библиотеки](https://reactrouter.com/en/main)


## 7.11 [React Context, useContext](https://ru.legacy.reactjs.org/docs/context.html)


## 7.12 useReducer

useReducer является альтернативой useState. 

## 7.13 [React Transition Group](https://reactcommunity.org/react-transition-group/)

React Transition Group позволяет делать плавные переходы между компонентами. 

## 7.14 [Formik, Yup и работа с формами любой сложности](https://formik.org/docs/overview)

[React Hook Form](https://react-hook-form.com/)